# MyBatis 模块测试用例设计文档

## 一、测试目标

验证 MyBatis 模块的核心功能是否正常工作，包括：
1. MyBatis-Plus 自动配置是否正确
2. MySQL 启动检查功能是否正常
3. 配置属性是否正确生效
4. MyBatis-Plus CRUD 操作是否正常（增删改查）
5. MyBatis-Plus 分页功能是否正常
6. MyBatis-Plus 翻页功能是否正常

## 二、测试用例设计

### 2.1 MyBatisPlusAutoConfiguration 测试用例

#### TC-001: 测试 MyBatis-Plus 拦截器 Bean 创建
- **测试目的**: 验证 `mybatisPlusInterceptor()` 方法能正确创建拦截器 Bean
- **测试步骤**:
  1. 启动 Spring 上下文
  2. 获取 `MybatisPlusInterceptor` Bean
  3. 验证 Bean 不为空
  4. 验证拦截器包含分页插件
- **预期结果**: 拦截器 Bean 创建成功，且包含 `PaginationInnerInterceptor`

#### TC-002: 测试条件注解 ConditionalOnMissingBean
- **测试目的**: 验证当已存在 `MybatisPlusInterceptor` Bean 时，不会重复创建
- **测试步骤**:
  1. 手动创建一个 `MybatisPlusInterceptor` Bean
  2. 启动 Spring 上下文
  3. 验证只存在一个拦截器 Bean（手动创建的那个）
- **预期结果**: 不会创建新的拦截器 Bean，使用已存在的 Bean

#### TC-003: 测试分页插件配置
- **测试目的**: 验证分页插件是否正确配置为 MySQL 类型
- **测试步骤**:
  1. 启动 Spring 上下文
  2. 获取 `MybatisPlusInterceptor` Bean
  3. 验证内部拦截器包含 `PaginationInnerInterceptor`
  4. 验证分页插件配置的数据库类型为 MySQL
- **预期结果**: 分页插件正确配置，数据库类型为 MySQL

#### TC-004: 测试 MySQLBootCheckRunner Bean 创建（启用检查）
- **测试目的**: 验证当 `mybatis.boot.check.enable=true` 时，Runner Bean 被创建
- **测试步骤**:
  1. 配置 `mybatis.boot.check.enable=true`
  2. 启动 Spring 上下文
  3. 验证 `MySQLBootCheckRunner` Bean 存在
- **预期结果**: Runner Bean 创建成功

#### TC-005: 测试 MySQLBootCheckRunner Bean 不创建（禁用检查）
- **测试目的**: 验证当 `mybatis.boot.check.enable=false` 时，Runner Bean 不被创建
- **测试步骤**:
  1. 配置 `mybatis.boot.check.enable=false`
  2. 启动 Spring 上下文
  3. 验证 `MySQLBootCheckRunner` Bean 不存在
- **预期结果**: Runner Bean 未被创建

### 2.2 MySQLBootCheckRunner 测试用例

#### TC-006: 测试无 Mapper 时的处理
- **测试目的**: 验证当没有 Mapper 时，检查逻辑能正常处理
- **测试步骤**:
  1. 启动不包含任何 Mapper 的 Spring 上下文
  2. 验证应用能正常启动
  3. 验证日志中输出警告信息
- **预期结果**: 应用正常启动，输出警告日志但不抛出异常

#### TC-007: 测试有 Mapper 且检查成功
- **测试目的**: 验证当存在 Mapper 且检查成功时的处理
- **测试步骤**:
  1. 创建一个测试 Mapper 和对应的实体
  2. 配置测试数据库连接
  3. 启动 Spring 上下文
  4. 验证检查逻辑执行成功
  5. 验证日志中输出成功信息
- **预期结果**: 检查成功，输出成功日志，应用正常启动

#### TC-008: 测试检查失败且 block=true
- **测试目的**: 验证当检查失败且 `block=true` 时，应用启动失败
- **测试步骤**:
  1. 创建一个有问题的 Mapper（如配置错误的 SQL）
  2. 配置 `mybatis.boot.check.block=true`
  3. 启动 Spring 上下文
  4. 验证应用启动失败并抛出异常
- **预期结果**: 应用启动失败，抛出 `RuntimeException`

#### TC-009: 测试检查失败且 block=false
- **测试目的**: 验证当检查失败且 `block=false` 时，应用仍能启动
- **测试步骤**:
  1. 创建一个有问题的 Mapper
  2. 配置 `mybatis.boot.check.block=false`
  3. 启动 Spring 上下文
  4. 验证应用能正常启动
  5. 验证日志中输出错误信息但不抛出异常
- **预期结果**: 应用正常启动，输出错误日志但不抛出异常

#### TC-010: 测试配置属性 block 的默认值
- **测试目的**: 验证 `block` 属性的默认值为 `true`
- **测试步骤**:
  1. 不配置 `mybatis.boot.check.block` 属性
  2. 创建一个有问题的 Mapper
  3. 启动 Spring 上下文
  4. 验证应用启动失败（因为默认 block=true）
- **预期结果**: 应用启动失败，说明默认值为 `true`

### 2.3 MyBatis-Plus CRUD 操作测试用例

#### TC-011: 测试插入操作（Create）
- **测试目的**: 验证 MyBatis-Plus 的插入功能是否正常
- **测试步骤**:
  1. 配置 H2 内存数据库
  2. 创建测试实体对象
  3. 调用 `insert()` 方法插入数据
  4. 验证插入成功，返回影响行数为 1
  5. 验证插入后实体 ID 被自动填充
- **预期结果**: 数据插入成功，ID 自动生成并填充到实体对象

#### TC-012: 测试查询操作（Read）
- **测试目的**: 验证 MyBatis-Plus 的查询功能是否正常
- **测试步骤**:
  1. 预先插入测试数据
  2. 使用 `selectById()` 根据 ID 查询
  3. 使用 `selectList()` 查询列表
  4. 使用 `selectOne()` 查询单条记录
  5. 使用条件构造器 `LambdaQueryWrapper` 进行条件查询
  6. 验证查询结果正确
- **预期结果**: 各种查询方法都能正确返回数据

#### TC-013: 测试更新操作（Update）
- **测试目的**: 验证 MyBatis-Plus 的更新功能是否正常
- **测试步骤**:
  1. 预先插入测试数据
  2. 修改实体对象的属性
  3. 调用 `updateById()` 根据 ID 更新
  4. 使用 `update()` 方法配合条件构造器更新
  5. 验证更新成功，返回影响行数正确
  6. 查询验证数据已更新
- **预期结果**: 数据更新成功，数据库中的数据已修改

#### TC-014: 测试删除操作（Delete）
- **测试目的**: 验证 MyBatis-Plus 的删除功能是否正常
- **测试步骤**:
  1. 预先插入测试数据
  2. 调用 `deleteById()` 根据 ID 删除
  3. 使用 `delete()` 方法配合条件构造器删除
  4. 验证删除成功，返回影响行数正确
  5. 查询验证数据已删除
- **预期结果**: 数据删除成功，数据库中对应的记录已删除

### 2.4 MyBatis-Plus 分页功能测试用例

#### TC-015: 测试分页查询（第一页）
- **测试目的**: 验证分页插件的第一页查询功能
- **测试步骤**:
  1. 预先插入多条测试数据（至少 10 条）
  2. 创建 `Page` 对象，设置当前页为 1，每页大小为 5
  3. 调用 `selectPage()` 方法进行分页查询
  4. 验证返回的 `Page` 对象包含正确的数据
  5. 验证分页信息：总记录数、总页数、当前页、每页大小
- **预期结果**: 分页查询成功，返回第一页的 5 条数据，分页信息正确

#### TC-016: 测试分页查询（中间页）
- **测试目的**: 验证分页插件的中间页查询功能
- **测试步骤**:
  1. 预先插入多条测试数据（至少 15 条）
  2. 创建 `Page` 对象，设置当前页为 2，每页大小为 5
  3. 调用 `selectPage()` 方法进行分页查询
  4. 验证返回的数据是第 6-10 条记录
  5. 验证分页信息正确
- **预期结果**: 分页查询成功，返回第二页的 5 条数据，分页信息正确

#### TC-017: 测试分页查询（最后一页）
- **测试目的**: 验证分页插件的最后一页查询功能
- **测试步骤**:
  1. 预先插入多条测试数据（例如 13 条）
  2. 创建 `Page` 对象，设置当前页为最后一页，每页大小为 5
  3. 调用 `selectPage()` 方法进行分页查询
  4. 验证返回的数据是最后 3 条记录（13 % 5 = 3）
  5. 验证分页信息：总页数、当前页等
- **预期结果**: 分页查询成功，返回最后一页的数据，数据条数可能少于每页大小

#### TC-018: 测试分页查询（空结果）
- **测试目的**: 验证分页查询在无数据时的处理
- **测试步骤**:
  1. 确保数据库中没有测试数据
  2. 创建 `Page` 对象，设置当前页为 1，每页大小为 5
  3. 调用 `selectPage()` 方法进行分页查询
  4. 验证返回的 `Page` 对象数据列表为空
  5. 验证分页信息：总记录数为 0，总页数为 0
- **预期结果**: 分页查询返回空列表，分页信息正确显示无数据

#### TC-019: 测试分页查询（带条件查询）
- **测试目的**: 验证分页查询配合条件构造器的功能
- **测试步骤**:
  1. 预先插入多条测试数据，包含不同的 name 值
  2. 创建 `Page` 对象和 `LambdaQueryWrapper` 条件构造器
  3. 设置查询条件（如 name like '%test%'）
  4. 调用 `selectPage()` 方法进行条件分页查询
  5. 验证返回的数据符合查询条件
  6. 验证分页信息正确
- **预期结果**: 条件分页查询成功，返回符合条件的数据，分页信息正确

#### TC-020: 测试分页查询（排序功能）
- **测试目的**: 验证分页查询配合排序功能
- **测试步骤**:
  1. 预先插入多条测试数据
  2. 创建 `Page` 对象和 `LambdaQueryWrapper` 条件构造器
  3. 设置排序条件（如按 id 降序、按 name 升序）
  4. 调用 `selectPage()` 方法进行排序分页查询
  5. 验证返回的数据按指定顺序排列
  6. 验证分页信息正确
- **预期结果**: 排序分页查询成功，数据按指定顺序返回，分页信息正确

### 2.5 MyBatis-Plus 翻页功能测试用例

#### TC-021: 测试翻页到下一页
- **测试目的**: 验证从第一页翻到第二页的功能
- **测试步骤**:
  1. 预先插入多条测试数据（至少 10 条）
  2. 查询第一页数据，验证数据正确
  3. 使用第一页的 `Page` 对象，调用 `next()` 或设置 `current` 为 2
  4. 再次调用 `selectPage()` 查询第二页
  5. 验证返回的数据是第二页的数据
  6. 验证分页信息更新正确
- **预期结果**: 翻页成功，返回第二页数据，分页信息正确

#### TC-022: 测试翻页到上一页
- **测试目的**: 验证从第二页翻到第一页的功能
- **测试步骤**:
  1. 预先插入多条测试数据（至少 10 条）
  2. 查询第二页数据，验证数据正确
  3. 使用第二页的 `Page` 对象，调用 `previous()` 或设置 `current` 为 1
  4. 再次调用 `selectPage()` 查询第一页
  5. 验证返回的数据是第一页的数据
  6. 验证分页信息更新正确
- **预期结果**: 翻页成功，返回第一页数据，分页信息正确

#### TC-023: 测试翻页边界处理（首页）
- **测试目的**: 验证在首页时不能向前翻页
- **测试步骤**:
  1. 预先插入多条测试数据
  2. 查询第一页数据
  3. 尝试翻到上一页（current = 0 或负数）
  4. 验证处理逻辑（应该保持在第一页或抛出异常）
- **预期结果**: 边界处理正确，不会翻到无效页面

#### TC-024: 测试翻页边界处理（末页）
- **测试目的**: 验证在末页时不能向后翻页
- **测试步骤**:
  1. 预先插入多条测试数据（例如 13 条，每页 5 条，共 3 页）
  2. 查询最后一页（第 3 页）数据
  3. 尝试翻到下一页（current = 4）
  4. 验证处理逻辑（应该保持在最后一页或返回空数据）
- **预期结果**: 边界处理正确，不会翻到无效页面

#### TC-025: 测试跳转到指定页
- **测试目的**: 验证直接跳转到指定页面的功能
- **测试步骤**:
  1. 预先插入多条测试数据（至少 15 条）
  2. 创建 `Page` 对象，直接设置 `current` 为 3
  3. 调用 `selectPage()` 查询第三页
  4. 验证返回的数据是第三页的数据
  5. 验证分页信息正确
- **预期结果**: 跳转成功，返回指定页数据，分页信息正确

## 三、测试环境要求

1. **测试框架**: 
   - JUnit 5
   - Spring Boot Test
   - Mockito（如需要）

2. **测试数据库**: 
   - 使用 H2 内存数据库进行集成测试
   - 或使用 Testcontainers 创建临时 MySQL 容器

3. **测试配置**:
   - 使用 `@TestConfiguration` 提供测试配置
   - 使用 `@SpringBootTest` 进行集成测试
   - 使用 `@MockBean` 模拟依赖（如需要）

## 四、测试数据准备

1. **测试 Mapper**: 创建一个简单的测试 Mapper 接口
2. **测试实体**: 创建一个简单的测试实体类
3. **测试表结构**: 准备对应的数据库表结构（如使用 H2）

## 五、测试用例与代码对应关系

### 5.1 已实现的测试用例

| 测试用例ID | 测试用例名称 | 实现类 | 状态 |
|-----------|------------|--------|------|
| TC-001 | 测试 MyBatis-Plus 拦截器 Bean 创建 | MyBatisPlusAutoConfigurationTest | ✅ 已实现 |
| TC-002 | 测试条件注解 ConditionalOnMissingBean | MyBatisPlusAutoConfigurationTest | ⚠️ 部分实现 |
| TC-003 | 测试分页插件配置 | MyBatisPlusAutoConfigurationTest | ✅ 已实现 |
| TC-004 | 测试 MySQLBootCheckRunner Bean 创建（启用检查） | MySQLBootCheckRunnerConditionalTest | ✅ 已实现 |
| TC-005 | 测试 MySQLBootCheckRunner Bean 不创建（禁用检查） | MySQLBootCheckRunnerDisabledTest | ✅ 已实现 |
| TC-006 | 测试无 Mapper 时的处理 | MySQLBootCheckRunnerBlockTest | ✅ 已实现 |
| TC-007 | 测试有 Mapper 且检查成功 | MySQLBootCheckRunnerMapperSuccessTest | ✅ 已实现 |
| TC-008 | 测试检查失败且 block=true | MySQLBootCheckRunnerBlockTrueTest | ✅ 已实现 |
| TC-009 | 测试检查失败且 block=false | MySQLBootCheckRunnerBlockTest | ✅ 已实现 |
| TC-010 | 测试配置属性 block 的默认值 | MySQLBootCheckRunnerTest | ✅ 已实现 |
| TC-011 | 测试插入操作（Create） | MyBatisPlusCrudTest | ✅ 已实现 |
| TC-012 | 测试查询操作（Read） | MyBatisPlusCrudTest | ✅ 已实现 |
| TC-013 | 测试更新操作（Update） | MyBatisPlusCrudTest | ✅ 已实现 |
| TC-014 | 测试删除操作（Delete） | MyBatisPlusCrudTest | ✅ 已实现 |
| TC-015 | 测试分页查询（第一页） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-016 | 测试分页查询（中间页） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-017 | 测试分页查询（最后一页） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-018 | 测试分页查询（空结果） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-019 | 测试分页查询（带条件查询） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-020 | 测试分页查询（排序功能） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-021 | 测试翻页到下一页 | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-022 | 测试翻页到上一页 | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-023 | 测试翻页边界处理（首页） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-024 | 测试翻页边界处理（末页） | MyBatisPlusPaginationTest | ✅ 已实现 |
| TC-025 | 测试跳转到指定页 | MyBatisPlusPaginationTest | ✅ 已实现 |

### 5.2 待实现的测试用例

目前所有测试用例（TC-001 到 TC-025）均已实现。

### 5.3 文档与代码不匹配情况

1. **TC-002 测试用例**：
   - 文档要求：验证当已存在 `MybatisPlusInterceptor` Bean 时，不会重复创建
   - 代码实现：仅验证拦截器存在，未真正测试条件注解逻辑
   - 建议：需要创建单独的测试类，手动创建 Bean 后验证不会重复创建

2. **TC-007 测试用例**：
   - 文档要求：验证日志中输出成功信息
   - 代码实现：仅验证 Mapper 可以正常使用，未验证日志输出
   - 建议：可以添加日志断言或使用日志捕获工具验证

3. **TC-008 和 TC-009 测试用例**：
   - 文档要求：需要创建有问题的 Mapper 来模拟错误场景
   - 代码实现：仅验证配置是否正确，未真正模拟错误场景
   - 建议：需要创建错误的 Mapper 配置来测试真实的错误处理

## 六、注意事项

1. 测试时需要注意 Spring 上下文的启动顺序
2. `MySQLBootCheckRunner` 使用 `@PostConstruct`，会在 Bean 创建后立即执行
3. 测试检查失败场景时，需要模拟真实的错误情况
4. 注意测试的隔离性，避免测试之间的相互影响
5. CRUD 和分页测试需要使用 H2 内存数据库，确保测试数据隔离
6. 分页测试需要准备足够的数据量，以验证分页逻辑的正确性
7. 翻页测试需要验证边界情况，确保不会出现数组越界等错误

